<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `context` mod in crate `rustacuda`."><meta name="keywords" content="rust, rustlang, rust-lang, context"><title>rustacuda::context - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../rustacuda/index.html'><div class='logo-container'><img src='../../rust-logo.png' alt='logo'></div></a><p class='location'>Module context</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></div><p class='location'><a href='../index.html'>rustacuda</a></p><script>window.sidebarCurrent = {name: 'context', ty: 'mod', relpath: '../'};</script><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../src/rustacuda/context.rs.html#1-848' title='goto source code'>[src]</a></span><span class='in-band'>Module <a href='../index.html'>rustacuda</a>::<wbr><a class="mod" href=''>context</a></span></h1><div class='docblock'><h1 id="cuda-context-management" class="section-header"><a href="#cuda-context-management">CUDA context management</a></h1>
<p>Most CUDA functions require a context. A CUDA context is analogous to a CPU process - it's
an isolated container for all runtime state, including configuration settings and the
device/unified/page-locked memory allocations. Each context has a separate memory space, and
pointers from one context do not work in another. Each context is associated with a single
device. Although it is possible to have multiple contexts associated with a single device, this
is strongly discouraged as it can cause a significant loss of performance.</p>
<p>CUDA keeps a thread-local stack of contexts which the programmer can push to or pop from.
The top context in that stack is known as the &quot;current&quot; context and it is used in most CUDA
API calls. One context can be safely made current in multiple CPU threads.</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>The CUDA context management API does not fit easily into Rust's safety guarantees.</p>
<p>The thread-local stack (as well as the fact that any context can be on the stack for any number
of threads) means there is no clear owner for a CUDA context, but it still has to be cleaned up.
Also, the fact that a context can be current to multiple threads at once means that there can be
multiple implicit references to a context which are not controlled by Rust.</p>
<p>RustaCUDA handles ownership by providing an owning <a href="struct.Context.html"><code>Context</code></a> struct and
a non-owning <a href="struct.UnownedContext.html"><code>UnownedContext</code></a>. When the <code>Context</code> is dropped, the
backing context is destroyed. The context could be current on other threads, though. In this
case, the context is still destroyed, and attempts to access the context on other threads will
fail with an error. This is (mostly) safe, if a bit inconvenient. It's only mostly safe because
other threads could be accessing that context while the destructor is running on this thread,
which could result in undefined behavior.</p>
<p>In short, Rust's thread-safety guarantees cannot fully protect use of the context management
functions. The programmer must ensure that no other OS threads are using the <code>Context</code> when it
is dropped.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>For most commmon uses (one device, one OS thread) it should suffice to create a single context:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rustacuda</span>::<span class="ident">device</span>::<span class="ident">Device</span>;
<span class="kw">use</span> <span class="ident">rustacuda</span>::<span class="ident">context</span>::{<span class="ident">Context</span>, <span class="ident">ContextFlags</span>};

<span class="ident">rustacuda</span>::<span class="ident">init</span>(<span class="ident">rustacuda</span>::<span class="ident">CudaFlags</span>::<span class="ident">empty</span>())<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">device</span> <span class="op">=</span> <span class="ident">Device</span>::<span class="ident">get_device</span>(<span class="number">0</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">context</span> <span class="op">=</span> <span class="ident">Context</span>::<span class="ident">create_and_push</span>(<span class="ident">ContextFlags</span>::<span class="ident">MAP_HOST</span> <span class="op">|</span> <span class="ident">ContextFlags</span>::<span class="ident">SCHED_AUTO</span>, <span class="ident">device</span>)<span class="question-mark">?</span>;
<span class="comment">// call RustaCUDA functions which use the context</span>

<span class="comment">// The context will be destroyed when dropped or it falls out of scope.</span>
<span class="ident">drop</span>(<span class="ident">context</span>);</pre></div>
<p>If you have multiple OS threads that each submit work to the same device, you can get a handle
to the single context and pass it to each thread.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// As before</span>
<span class="kw">let</span> <span class="ident">context</span> <span class="op">=</span>
    <span class="ident">Context</span>::<span class="ident">create_and_push</span>(<span class="ident">ContextFlags</span>::<span class="ident">MAP_HOST</span> <span class="op">|</span> <span class="ident">ContextFlags</span>::<span class="ident">SCHED_AUTO</span>, <span class="ident">device</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">join_handles</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];

<span class="kw">for</span> <span class="kw">_</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">4</span> {
    <span class="kw">let</span> <span class="ident">unowned</span> <span class="op">=</span> <span class="ident">context</span>.<span class="ident">get_unowned</span>();
    <span class="kw">let</span> <span class="ident">join_handle</span> <span class="op">=</span> <span class="ident">std</span>::<span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
        <span class="ident">CurrentContext</span>::<span class="ident">set_current</span>(<span class="kw-2">&amp;</span><span class="ident">unowned</span>).<span class="ident">unwrap</span>();
        <span class="comment">// Call RustaCUDA functions which use the context</span>
    });
    <span class="ident">join_handles</span>.<span class="ident">push</span>(<span class="ident">join_handle</span>);
}
<span class="comment">// We must ensure that the other threads are not using the context when it&#39;s destroyed.</span>
<span class="kw">for</span> <span class="ident">handle</span> <span class="kw">in</span> <span class="ident">join_handles</span> {
    <span class="ident">handle</span>.<span class="ident">join</span>().<span class="ident">unwrap</span>();
}
<span class="comment">// Now it&#39;s safe to drop the context.</span>
<span class="ident">drop</span>(<span class="ident">context</span>);</pre></div>
<p>If you have multiple devices, each device needs its own context.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Create and pop contexts for each device</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">contexts</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
<span class="kw">for</span> <span class="ident">device</span> <span class="kw">in</span> <span class="ident">Device</span>::<span class="ident">devices</span>()<span class="question-mark">?</span> {
    <span class="kw">let</span> <span class="ident">device</span> <span class="op">=</span> <span class="ident">device</span><span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="ident">ctx</span> <span class="op">=</span>
        <span class="ident">Context</span>::<span class="ident">create_and_push</span>(<span class="ident">ContextFlags</span>::<span class="ident">MAP_HOST</span> <span class="op">|</span> <span class="ident">ContextFlags</span>::<span class="ident">SCHED_AUTO</span>, <span class="ident">device</span>)<span class="question-mark">?</span>;
    <span class="ident">ContextStack</span>::<span class="ident">pop</span>()<span class="question-mark">?</span>;
    <span class="ident">contexts</span>.<span class="ident">push</span>(<span class="ident">ctx</span>);
}
<span class="ident">CurrentContext</span>::<span class="ident">set_current</span>(<span class="kw-2">&amp;</span><span class="ident">contexts</span>[<span class="number">0</span>])<span class="question-mark">?</span>;

<span class="comment">// Call RustaCUDA functions which will use the context</span>
</pre></div>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.Context.html" title='rustacuda::context::Context struct'>Context</a></td><td class='docblock-short'><p>Owned handle to a CUDA context.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.ContextFlags.html" title='rustacuda::context::ContextFlags struct'>ContextFlags</a></td><td class='docblock-short'><p>Bit flags for initializing the CUDA context.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.ContextStack.html" title='rustacuda::context::ContextStack struct'>ContextStack</a></td><td class='docblock-short'><p>Type used to represent the thread-local context stack.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.CurrentContext.html" title='rustacuda::context::CurrentContext struct'>CurrentContext</a></td><td class='docblock-short'><p>Type representing the top context in the thread-local stack.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.StreamPriorityRange.html" title='rustacuda::context::StreamPriorityRange struct'>StreamPriorityRange</a></td><td class='docblock-short'><p>Struct representing a range of stream priorities.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.UnownedContext.html" title='rustacuda::context::UnownedContext struct'>UnownedContext</a></td><td class='docblock-short'><p>Non-owning handle to a CUDA context.</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.CacheConfig.html" title='rustacuda::context::CacheConfig enum'>CacheConfig</a></td><td class='docblock-short'><p>This enumeration represents configuration settings for devices which share hardware resources
between L1 cache and shared memory.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.ResourceLimit.html" title='rustacuda::context::ResourceLimit enum'>ResourceLimit</a></td><td class='docblock-short'><p>This enumeration represents the limited resources which can be accessed through
<a href="struct.CurrentContext.html#method.get_resource_limit">CurrentContext::get_resource_limit</a> and
<a href="struct.CurrentContext.html#method.set_resource_limit">CurrentContext::set_resource_limit</a>.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.SharedMemoryConfig.html" title='rustacuda::context::SharedMemoryConfig enum'>SharedMemoryConfig</a></td><td class='docblock-short'><p>This enumeration represents the options for configuring the shared memory bank size.</p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.ContextHandle.html" title='rustacuda::context::ContextHandle trait'>ContextHandle</a></td><td class='docblock-short'><p>Sealed trait for <code>Context</code> and <code>UnownedContext</code>. Not intended for use outside of RustaCUDA.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../";window.currentCrate = "rustacuda";</script><script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>