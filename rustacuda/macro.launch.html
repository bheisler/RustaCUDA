<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `launch` macro in crate `rustacuda`."><meta name="keywords" content="rust, rustlang, rust-lang, launch"><title>rustacuda::launch - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc macro"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../rustacuda/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><div class="sidebar-elems"><p class='location'><a href='index.html'>rustacuda</a></p><script>window.sidebarCurrent = {name: 'launch', ty: 'macro', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/rustacuda/function.rs.html#383-412' title='goto source code'>[src]</a></span><span class='in-band'>Macro <a href='index.html'>rustacuda</a>::<wbr><a class="macro" href=''>launch</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><div class="example-wrap"><pre class="rust macro">
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">launch</span> {
    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">module</span>:<span class="ident">ident</span> . <span class="macro-nonterminal">$</span><span class="macro-nonterminal">function</span>:<span class="ident">ident</span> <span class="op">&lt;</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">grid</span>:<span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">block</span>:<span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">shared</span>:<span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">stream</span>:<span class="ident">ident</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>( $( <span class="macro-nonterminal">$</span><span class="macro-nonterminal">arg</span>:<span class="ident">expr</span>),<span class="op">*</span> )) <span class="op">=</span><span class="op">&gt;</span> { ... };
    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">function</span>:<span class="ident">ident</span> <span class="op">&lt;</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">grid</span>:<span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">block</span>:<span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">shared</span>:<span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">stream</span>:<span class="ident">ident</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>( $( <span class="macro-nonterminal">$</span><span class="macro-nonterminal">arg</span>:<span class="ident">expr</span>),<span class="op">*</span> )) <span class="op">=</span><span class="op">&gt;</span> { ... };
}</pre></div>
</div><div class='docblock'><p>Launch a kernel function asynchronously.</p>
<h1 id="syntax" class="section-header"><a href="#syntax">Syntax:</a></h1>
<p>The format of this macro is designed to resemble the triple-chevron syntax used to launch
kernels in CUDA C. There are two forms available:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="macro">launch</span><span class="macro">!</span>(<span class="ident">module</span>.<span class="ident">function_name</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="ident">grid</span>, <span class="ident">block</span>, <span class="ident">shared_memory_size</span>, <span class="ident">stream</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">parameter1</span>, <span class="ident">parameter2</span>...));</pre></div>
<p>This will load a kernel called <code>function_name</code> from the module <code>module</code> and launch it with
the given grid/block size on the given stream. Unlike in CUDA C, the shared memory size and
stream parameters are not optional. The shared memory size is a number of bytes per thread for
dynamic shared memory (Note that this uses <code>extern __shared__ int x[]</code> in CUDA C, not the
fixed-length arrays created by <code>__shared__ int x[64]</code>. This will usually be zero.).
<code>stream</code> must be the name of a <a href="stream/struct.Stream.html"><code>Stream</code></a> value.
<code>grid</code> can be any value which implements <a href="function/struct.GridSize.html"><code>Into&lt;GridSize&gt;</code></a> (such as
<code>u32</code> values, tuples of up to three <code>u32</code> values, and GridSize structures) and likewise <code>block</code>
can be any value that implements <a href="function/struct.BlockSize.html"><code>Into&lt;BlockSize&gt;</code></a>.</p>
<p>NOTE: due to some limitations of Rust's macro system, <code>module</code> and <code>stream</code> must be local
variable names. Paths or function calls will not work.</p>
<p>The second form is similar:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="macro">launch</span><span class="macro">!</span>(<span class="ident">function</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="ident">grid</span>, <span class="ident">block</span>, <span class="ident">shared_memory_size</span>, <span class="ident">stream</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">parameter1</span>, <span class="ident">parameter2</span>...));</pre></div>
<p>In this variant, the <code>function</code> parameter must be a variable. Use this form to avoid looking up
the kernel function for each call.</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>Launching kernels must be done in an <code>unsafe</code> block. Calling a kernel is similar to calling a
foreign-language function, as the kernel itself could be written in C or unsafe Rust. The kernel
must accept the same number and type of parameters that are passed to the <code>launch!</code> macro. The
kernel must not write invalid data (for example, invalid enums) into areas of memory that can
be copied back to the host. The programmer must ensure that the host does not access device or
unified memory that the kernel could write to until after calling <code>stream.synchronize()</code>.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rustacuda</span>::<span class="ident">memory</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">rustacuda</span>::<span class="ident">module</span>::<span class="ident">Module</span>;
<span class="kw">use</span> <span class="ident">rustacuda</span>::<span class="ident">stream</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">ffi</span>::<span class="ident">CString</span>;


<span class="comment">// Set up the context, load the module, and create a stream to run kernels in.</span>
<span class="kw">let</span> <span class="ident">_ctx</span> <span class="op">=</span> <span class="ident">rustacuda</span>::<span class="ident">quick_init</span>()<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">ptx</span> <span class="op">=</span> <span class="ident">CString</span>::<span class="ident">new</span>(<span class="macro">include_str</span><span class="macro">!</span>(<span class="string">&quot;../resources/add.ptx&quot;</span>))<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module</span>::<span class="ident">load_from_string</span>(<span class="kw-2">&amp;</span><span class="ident">ptx</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">Stream</span>::<span class="ident">new</span>(<span class="ident">StreamFlags</span>::<span class="ident">NON_BLOCKING</span>, <span class="prelude-val">None</span>)<span class="question-mark">?</span>;

<span class="comment">// Create buffers for data</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">in_x</span> <span class="op">=</span> <span class="ident">DeviceBuffer</span>::<span class="ident">from_slice</span>(<span class="kw-2">&amp;</span>[<span class="number">1.0f32</span>; <span class="number">10</span>])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">in_y</span> <span class="op">=</span> <span class="ident">DeviceBuffer</span>::<span class="ident">from_slice</span>(<span class="kw-2">&amp;</span>[<span class="number">2.0f32</span>; <span class="number">10</span>])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">out_1</span> <span class="op">=</span> <span class="ident">DeviceBuffer</span>::<span class="ident">from_slice</span>(<span class="kw-2">&amp;</span>[<span class="number">0.0f32</span>; <span class="number">10</span>])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">out_2</span> <span class="op">=</span> <span class="ident">DeviceBuffer</span>::<span class="ident">from_slice</span>(<span class="kw-2">&amp;</span>[<span class="number">0.0f32</span>; <span class="number">10</span>])<span class="question-mark">?</span>;

<span class="comment">// This kernel adds each element in `in_x` and `in_y` and writes the result into `out`.</span>
<span class="kw">unsafe</span> {
    <span class="comment">// Launch the kernel with one block of one thread, no dynamic shared memory on `stream`.</span>
    <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="macro">launch</span><span class="macro">!</span>(<span class="ident">module</span>.<span class="ident">sum</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="ident">stream</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>(
        <span class="ident">in_x</span>.<span class="ident">as_device_ptr</span>(),
        <span class="ident">in_y</span>.<span class="ident">as_device_ptr</span>(),
        <span class="ident">out_1</span>.<span class="ident">as_device_ptr</span>(),
        <span class="ident">out_1</span>.<span class="ident">len</span>()
    ));
    <span class="comment">// `launch!` returns an error in case anything went wrong with the launch itself, but</span>
    <span class="comment">// kernel launches are asynchronous so errors caused by the kernel (eg. invalid memory</span>
    <span class="comment">// access) will show up later at some other CUDA API call (probably at `synchronize()`</span>
    <span class="comment">// below).</span>
    <span class="ident">result</span><span class="question-mark">?</span>;

    <span class="comment">// Launch the kernel again using the `function` form:</span>
    <span class="kw">let</span> <span class="ident">function_name</span> <span class="op">=</span> <span class="ident">CString</span>::<span class="ident">new</span>(<span class="string">&quot;sum&quot;</span>)<span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="ident">sum</span> <span class="op">=</span> <span class="ident">module</span>.<span class="ident">get_function</span>(<span class="kw-2">&amp;</span><span class="ident">function_name</span>)<span class="question-mark">?</span>;
    <span class="comment">// Launch with 1x1x1 (1) blocks of 10x1x1 (10) threads, to show that you can use tuples to</span>
    <span class="comment">// configure grid and block size.</span>
    <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="macro">launch</span><span class="macro">!</span>(<span class="ident">sum</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="op">&lt;</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="number">0</span>, <span class="ident">stream</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>(
        <span class="ident">in_x</span>.<span class="ident">as_device_ptr</span>(),
        <span class="ident">in_y</span>.<span class="ident">as_device_ptr</span>(),
        <span class="ident">out_2</span>.<span class="ident">as_device_ptr</span>(),
        <span class="ident">out_2</span>.<span class="ident">len</span>()
    ));
    <span class="ident">result</span><span class="question-mark">?</span>;
}

<span class="comment">// Kernel launches are asynchronous, so we wait for the kernels to finish executing.</span>
<span class="ident">stream</span>.<span class="ident">synchronize</span>()<span class="question-mark">?</span>;

<span class="comment">// Copy the results back to host memory</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">out_host</span> <span class="op">=</span> [<span class="number">0.0f32</span>; <span class="number">20</span>];
<span class="ident">out_1</span>.<span class="ident">copy_to</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">out_host</span>[<span class="number">0</span>..<span class="number">10</span>])<span class="question-mark">?</span>;
<span class="ident">out_2</span>.<span class="ident">copy_to</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">out_host</span>[<span class="number">10</span>..<span class="number">20</span>])<span class="question-mark">?</span>;

<span class="kw">for</span> <span class="ident">x</span> <span class="kw">in</span> <span class="ident">out_host</span>.<span class="ident">iter</span>() {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">3.0</span>, <span class="kw-2">*</span><span class="ident">x</span>);
}</pre></div>
</div></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "rustacuda";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>